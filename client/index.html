<html>
<head>
		<title>Rootkit10</title>
		<meta name="description" content="A real-time strategy game about hacking">
		<meta name="keywords" content="Cyberpunk,Hacking,Hacker,Game,RTS">
		<meta name="author" content="William Dyce">
		<style>
			* { 
				margin: 0; 
				background-color : transparent;
				border: none;
				color: green;
				outline: none;
				border: none;
				outline: none;
				font-size: 32;
				font-family: monospace; 
			}
			canvas { 
				width: 100%; 
				height: 100% 
			}
			#history > div {
				min-height: 32px;
			}
		</style>
    <script src="pixi.js"></script>
</head>
<body>

	<div style="position: absolute; bottom: 0; width: 50%; 
	z-index: 1; overflow: hidden">
		<div id="history" >
		</div>
		<div>
			<div style="display:inline-block">></div>
			<div style="display:inline-block">
				<input type="text" id="cli" onblur="this.focus()" 
					spellcheck="false" maxlength="32" autofocus>
				</input>
			</div>
		</div>
	</div>


	<script src="socket.io-1.2.0.js"></script>

  <script>
 

window.onload = function() {

// ----------------------------------------------------------------------------
// SET UP SOCKET.IO
// ----------------------------------------------------------------------------

 var socket = null; // create later at user request

// ----------------------------------------------------------------------------
// SET UP PIXI.JS
// ----------------------------------------------------------------------------

var DEFAULT_W = 1024
var DEFAULT_H = 720

renderer = PIXI.autoDetectRenderer(window.innerWidth, window.innerHeight, {
	backgroundColor : 0x000000
});

stage = new PIXI.Stage(0xFFFFFF);
bloom = new PIXI.filters.BloomFilter();
 
// set the filter
stage.filters = [ bloom ];
renderer.view.style["transform"] = "translatez(0)";
document.body.appendChild(renderer.view);
renderer.view.style.position = "absolute";

var scaleNode = new PIXI.Container();
stage.addChild(scaleNode);

// ----------------------------------------------------------------------------
// GAME OBJECTS
// ----------------------------------------------------------------------------

// ------------------------------------
// Egg
// ------------------------------------

function Egg(tile)
{
	this.tile = tile;
	this.sprite = new PIXI.Sprite(this.texture);
	this.sprite.anchor.x = this.sprite.anchor.y = 0.5;
	tile.addChild(this.sprite);
	this.sprite.scale.x = this.sprite.scale.y = 2;
	return this;
}
Egg.prototype.texture = PIXI.Texture.fromImage("egg.png");

// ------------------------------------
// Kitten
// ------------------------------------

function Kitten(tile)
{
	this.tile = tile;
	this.sprite = new PIXI.Sprite(this.texture);
	this.sprite.anchor.x = this.sprite.anchor.y = 0.5;
	tile.addChild(this.sprite);
	this.sprite.scale.x = this.sprite.scale.y = 2;
	return this;
}
Kitten.prototype.texture = PIXI.Texture.fromImage("kitten.png");


// ----------------------------------------------------------------------------
// GAME STATES
// ----------------------------------------------------------------------------

// ------------------------------------
// State manager
// ------------------------------------

var state = null;

var title = null;
var ingame = null;

var statePrototype = {
	set : function(newState) {
		if(state)
		{
			state.exit();
			scaleNode.removeChildren();
		}
		scaleNode.addChild(newState.enter());
		state = newState;
	}
}

// ------------------------------------
// Title state
// ------------------------------------

title = {
	enter : function() {
		var root = new PIXI.Container();

		var text = new PIXI.Text("R00tK1t10", {
			font: "64px monospace", 
			fill: "green",
			align: "center"
		});
		text.position.x = -text.width*0.5;
		root.addChild(text);

		return root;
	},

	exit : function() {},

	animate : function() {},

	commands : {
		"enter" : {
			execute : function(args) {
				var server = (args[1] || "localhost");
				history.push("Enter - Connecting to server " + server);
				socket = io.connect(server, {
					forceNew : true
				});
				socket.on("connection", function() {
					history.push("Enter - Connection established");
					state.set(ingame);
				});
				return null;
			}
		}
	}
}
title.__proto__ = statePrototype;
statePrototype.set(title);

// ------------------------------------
// In-game state
// ------------------------------------

var GRID_W = 10
var GRID_H = 10
var TILE_W = 51
var TILE_H = 51

var grid = null

var unhashTile = function(s)
{
	return grid.tileHash[s];
}

ingame = {

	enter : function() {

		// out with the old...
		grid = {};
		grid.tileList = [];
		grid.tileHash = {};

		// ... in with the new
		var root = new PIXI.Container();
		root.position.x = 256;
		root.position.y = -32;

		var font = {
			font: "32px monospace", 
			fill: "green",
			align: "center"
		};
		var background = PIXI.Texture.fromImage("tile.png");

		for(var x = 0; x < GRID_W; x++)
		{
			// numbers across the top
			var text = new PIXI.Text(""+x, font);
			root.addChild(text);
			text.position.x = (2 + x)*TILE_W;
			text.position.y = 32;

			for(var y = 0; y < GRID_H; y++)
			{
				// letters down the left side
				var letter = String.fromCharCode(65 + y);
				if(x === 0)
				{	
					var text = new PIXI.Text(letter, font);
					root.addChild(text);
					text.position.x = 32;
					text.position.y = (1.85 + y)*TILE_H;
				}

				// add tile to scene graph
				var tile = new PIXI.Container();
				tile.position.x = (2.25 + x)*TILE_W;
				tile.position.y = (2.25 + y)*TILE_H;
				root.addChild(tile);

				// add background
				var b = new PIXI.Sprite(background)
				tile.addChild(b);
				b.anchor.x = 0.5;
				b.anchor.y = 0.5;

				// memorise tile information for game logic
				tile.id = letter+x;
				tile.grid_x = x;
				tile.grid_y = y;

				// save the tile in look-up tables
				grid.tileList[GRID_W*y + x] = tile;
				grid.tileHash[tile.id] = tile; 
			}
		}

		root.position.x -= root.width*0.5;
		root.position.y -= root.height*0.5;

		return root;
	},

	exit : function() {},

	animate : function() {

	},

	commands : {
		"exit" : {
			execute : function(args) {
					socket.disconnect();
					socket = null;
					state.set(title);
					history.push("Exit - Disconnected");
					return null;
			}
		},
		"spawn" : {
			execute : function(args) {
				if(!args[1])
					return "Spawn - missing position argument";
				var t = unhashTile(args[1])
				if(t)
				{
					if(t.children.length > 1)
						return "Spawn - obstruction at position " + t.id;
					else
					{
						new Egg(t);
						history.push("Spawn - successful at position " + t.id);
						return null;
					}
				}
				else
					return "Spawn - invalid position argument";
			}
		}
	},

	command : {
		execute : function(args) {
			switch(args[0])
			{
				case "exit":

					break;

				case "spawn":

			}
		}
	}
}
ingame.__proto__ = statePrototype;

function animate()
{
	state.animate();
	renderer.render(stage);
	requestAnimationFrame(animate);

	// force resize
	if(window.innerWidth !== w || window.innerHeight !== h)
		resize();
}	
animate();


// ----------------------------------------------------------------------------
// DOM
// ----------------------------------------------------------------------------

// ------------------------------------
// Resolution changes
// ------------------------------------

var w = window.innerWidth;
var h = window.innerHeight;

function resize()
{	
	var w = window.innerWidth;
	var h = window.innerHeight;
	renderer.resize(w, h);
	stage.filterArea = new PIXI.math.Rectangle(0, 0, w, h);
	var scale = Math.min(w/DEFAULT_W, h/DEFAULT_H);
	scaleNode.scale.x = scaleNode.scale.y = scale;
	scaleNode.position.x = w/2;
	scaleNode.position.y = h/2;
}
resize();

window.onresize = function(e) {
	resize();
}

// ------------------------------------
// User input
// ------------------------------------

//
// History
//

var HISTORY_LENGTH = 30;
var history = document.getElementById('history');
for(var i = 0; i < HISTORY_LENGTH; i++)
{
	var d = document.createElement('div'); 
	d.innerHTML = "";
	history.appendChild(d);
}

history.push = function (msg)
{
	for(var i = 1; i < history.childNodes.length; i++)
	{
		if(typeof history.childNodes[i].innerHTML === undefined)
			continue;
		history.childNodes[i - 1].innerHTML = history.childNodes[i].innerHTML;
	}
	history.childNodes[history.childNodes.length - 1].innerHTML = msg;
}

history.clear = function()
{
	for(var i = 0; i < history.childNodes.length; i++)
	{
		if(typeof history.childNodes[i].innerHTML === undefined)
			continue;
		history.childNodes[i].innerHTML = "";
	}
}

//
// Input
//

var cli = document.getElementById('cli');
cli.onkeydown = function(e) {
	e = (e || window.event)
	switch(e.keyCode || e.which)
	{
		case 9:
			cli.value = cli.autocomplete(cli.value);
			return false;

		case 13:
			cli.inputCommand(cli.value);
			cli.value = "";
			return false;
	}
}


cli.autocomplete = function(cmd)
{
	return "Hello World!";
}

cli.inputCommand = function(cmd)
{
	// space
	if(!cmd)
	{
		history.push("");
		return;
	}

	// arguments
	var args = cmd.split(" ");

	// try to apply command
	var success;
	var save_to_history = true;
	switch(args[0])
	{
		// global commands
		case "clear":
			history.clear();
			save_to_history = false;
			success = true;
			break;

		case "help":
			history.push("Help - available commands:");
			for(var i in state.commands)
				history.push(i);
			success = true;
			break;	

		default:
			// state-specific commands
			var implementation = state.commands[args[0]];
			if(!implementation)
				history.push("Command not found: " + args[0]);
			else
			{
				var error = implementation.execute(args);
				if(error)
					history.push(error);
			}
		break;
	}
		
}

} // window.onload

    </script>
 
    </body>
</html>